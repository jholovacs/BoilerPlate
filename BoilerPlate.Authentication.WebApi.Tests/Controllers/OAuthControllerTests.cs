using BoilerPlate.Authentication.Abstractions.Models;
using BoilerPlate.Authentication.Abstractions.Services;
using BoilerPlate.Authentication.Database.Entities;
using BoilerPlate.Authentication.WebApi.Configuration;
using BoilerPlate.Authentication.WebApi.Controllers;
using BoilerPlate.Authentication.WebApi.Models;
using BoilerPlate.Authentication.WebApi.Services;
using FluentAssertions;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Moq;
using System.Security.Claims;
using Xunit;

namespace BoilerPlate.Authentication.WebApi.Tests.Controllers;

/// <summary>
/// Unit tests for OAuthController
/// </summary>
public class OAuthControllerTests
{
    private readonly Mock<IAuthenticationService> _authenticationServiceMock;
    private readonly Mock<IUserService> _userServiceMock;
    private readonly Mock<UserManager<ApplicationUser>> _userManagerMock;
    private readonly JwtTokenService _jwtTokenService;
    private readonly JwtSettings _jwtSettings;
    private readonly Mock<ILogger<OAuthController>> _loggerMock;
    private readonly OAuthController _controller;

    public OAuthControllerTests()
    {
        _authenticationServiceMock = new Mock<IAuthenticationService>();
        _userServiceMock = new Mock<IUserService>();
        _userManagerMock = CreateUserManagerMock();
        var (privateKey, publicKey) = BoilerPlate.Authentication.WebApi.Utilities.RsaKeyGenerator.GenerateKeyPair();
        var jwtSettings = new JwtSettings
        {
            Issuer = "test-issuer",
            Audience = "test-audience",
            ExpirationMinutes = 60,
            PrivateKey = privateKey,
            PublicKey = publicKey
        };
        _jwtTokenService = new JwtTokenService(Options.Create(jwtSettings));
        _jwtSettings = new JwtSettings
        {
            Issuer = "test-issuer",
            Audience = "test-audience",
            ExpirationMinutes = 60
        };
        _loggerMock = new Mock<ILogger<OAuthController>>();

        _controller = new OAuthController(
            _authenticationServiceMock.Object,
            _userServiceMock.Object,
            _userManagerMock.Object,
            _jwtTokenService,
            Options.Create(_jwtSettings),
            _loggerMock.Object);
    }

    #region Token Endpoint Tests

    /// <summary>
    /// Test case: Token endpoint should return a valid OAuth2 token response when provided with valid credentials.
    /// Scenario: A valid OAuthTokenRequest with correct username, password, and tenant ID is submitted. The authentication service successfully authenticates the user, and the controller generates and returns an OAuthTokenResponse containing an access token, refresh token, token type (Bearer), and expiration time in seconds.
    /// </summary>
    [Fact]
    public async Task Token_WithValidCredentials_ShouldReturnTokenResponse()
    {
        // Arrange
        var userId = Guid.NewGuid();
        var tenantId = Guid.NewGuid();
        var user = new ApplicationUser
        {
            Id = userId,
            UserName = "testuser",
            Email = "test@example.com",
            TenantId = tenantId
        };

        var authResult = new AuthResult
        {
            Succeeded = true,
            User = new UserDto
            {
                Id = userId,
                UserName = "testuser",
                Email = "test@example.com",
                TenantId = tenantId
            }
        };

        var request = new OAuthTokenRequest
        {
            GrantType = "password",
            Username = "testuser",
            Password = "Password123!",
            TenantId = tenantId
        };

        _authenticationServiceMock
            .Setup(x => x.LoginAsync(It.IsAny<LoginRequest>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(authResult);

        _userManagerMock
            .Setup(x => x.FindByIdAsync(userId.ToString()))
            .ReturnsAsync(user);

        _userManagerMock
            .Setup(x => x.GetRolesAsync(It.IsAny<ApplicationUser>()))
            .ReturnsAsync(new[] { "User" });

        // Note: JwtTokenService methods are not virtual, so we use the real implementation
        // The token will be generated by the actual service

        // Act
        var result = await _controller.Token(request, CancellationToken.None);

        // Assert
        result.Should().BeOfType<OkObjectResult>();
        var okResult = result as OkObjectResult;
        okResult!.Value.Should().BeOfType<OAuthTokenResponse>();
        
        var response = okResult.Value as OAuthTokenResponse;
        response!.AccessToken.Should().NotBeNullOrEmpty();
        response.RefreshToken.Should().NotBeNullOrEmpty();
        response.TokenType.Should().Be("Bearer");
        response.ExpiresIn.Should().Be(_jwtSettings.ExpirationMinutes * 60);
    }

    /// <summary>
    /// Test case: Token endpoint should return a BadRequest when an unsupported grant type is provided.
    /// Scenario: An OAuthTokenRequest is submitted with a grant type other than "password" (e.g., "authorization_code"). The controller should return a BadRequestObjectResult with an error message indicating that only the password grant type is supported.
    /// </summary>
    [Fact]
    public async Task Token_WithInvalidGrantType_ShouldReturnBadRequest()
    {
        // Arrange
        var request = new OAuthTokenRequest
        {
            GrantType = "authorization_code",
            Username = "testuser",
            Password = "Password123!"
        };

        // Act
        var result = await _controller.Token(request, CancellationToken.None);

        // Assert
        result.Should().BeOfType<BadRequestObjectResult>();
        var badRequest = result as BadRequestObjectResult;
        badRequest!.Value.Should().NotBeNull();
    }

    /// <summary>
    /// Test case: Token endpoint should return a BadRequest when the username is missing or empty.
    /// Scenario: An OAuthTokenRequest is submitted with an empty or whitespace username. The controller should return a BadRequestObjectResult indicating that both username and password are required for authentication.
    /// </summary>
    [Fact]
    public async Task Token_WithMissingUsername_ShouldReturnBadRequest()
    {
        // Arrange
        var request = new OAuthTokenRequest
        {
            GrantType = "password",
            Username = string.Empty,
            Password = "Password123!"
        };

        // Act
        var result = await _controller.Token(request, CancellationToken.None);

        // Assert
        result.Should().BeOfType<BadRequestObjectResult>();
    }

    /// <summary>
    /// Test case: Token endpoint should return a BadRequest when the password is missing or empty.
    /// Scenario: An OAuthTokenRequest is submitted with an empty or whitespace password. The controller should return a BadRequestObjectResult indicating that both username and password are required for authentication.
    /// </summary>
    [Fact]
    public async Task Token_WithMissingPassword_ShouldReturnBadRequest()
    {
        // Arrange
        var request = new OAuthTokenRequest
        {
            GrantType = "password",
            Username = "testuser",
            Password = string.Empty
        };

        // Act
        var result = await _controller.Token(request, CancellationToken.None);

        // Assert
        result.Should().BeOfType<BadRequestObjectResult>();
    }

    /// <summary>
    /// Test case: Token endpoint should return Unauthorized when authentication fails due to invalid credentials.
    /// Scenario: An OAuthTokenRequest is submitted with incorrect username or password. The authentication service returns a failed AuthResult. The controller should return an UnauthorizedObjectResult with an error indicating invalid credentials, preventing unauthorized access.
    /// </summary>
    [Fact]
    public async Task Token_WithInvalidCredentials_ShouldReturnUnauthorized()
    {
        // Arrange
        var request = new OAuthTokenRequest
        {
            GrantType = "password",
            Username = "testuser",
            Password = "WrongPassword"
        };

        var authResult = new AuthResult
        {
            Succeeded = false,
            User = null
        };

        _authenticationServiceMock
            .Setup(x => x.LoginAsync(It.IsAny<LoginRequest>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(authResult);

        // Act
        var result = await _controller.Token(request, CancellationToken.None);

        // Assert
        result.Should().BeOfType<UnauthorizedObjectResult>();
    }

    /// <summary>
    /// Test case: Token endpoint should return Unauthorized when the authenticated user cannot be found in the user manager.
    /// Scenario: Authentication succeeds but the user cannot be retrieved from UserManager (e.g., user was deleted after authentication). The controller should return an UnauthorizedObjectResult, handling the edge case where authentication succeeded but user lookup fails.
    /// </summary>
    [Fact]
    public async Task Token_WithAuthenticationFailure_ShouldReturnUnauthorized()
    {
        // Arrange
        var request = new OAuthTokenRequest
        {
            GrantType = "password",
            Username = "testuser",
            Password = "Password123!"
        };

        var authResult = new AuthResult
        {
            Succeeded = true,
            User = new UserDto { Id = Guid.NewGuid() }
        };

        _authenticationServiceMock
            .Setup(x => x.LoginAsync(It.IsAny<LoginRequest>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(authResult);

        _userManagerMock
            .Setup(x => x.FindByIdAsync(It.IsAny<string>()))
            .ReturnsAsync((ApplicationUser?)null);

        // Act
        var result = await _controller.Token(request, CancellationToken.None);

        // Assert
        result.Should().BeOfType<UnauthorizedObjectResult>();
    }

    /// <summary>
    /// Test case: Token endpoint should include the requested scope in the token response when provided.
    /// Scenario: An OAuthTokenRequest is submitted with a scope parameter (e.g., "read write"). After successful authentication and token generation, the OAuthTokenResponse should include the same scope value, allowing the client to confirm which permissions were granted.
    /// </summary>
    [Fact]
    public async Task Token_ShouldIncludeScopeInResponse()
    {
        // Arrange
        var userId = Guid.NewGuid();
        var user = new ApplicationUser
        {
            Id = userId,
            UserName = "testuser",
            Email = "test@example.com",
            TenantId = Guid.NewGuid()
        };

        var authResult = new AuthResult
        {
            Succeeded = true,
            User = new UserDto { Id = userId }
        };

        var request = new OAuthTokenRequest
        {
            GrantType = "password",
            Username = "testuser",
            Password = "Password123!",
            Scope = "read write"
        };

        _authenticationServiceMock
            .Setup(x => x.LoginAsync(It.IsAny<LoginRequest>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(authResult);

        _userManagerMock
            .Setup(x => x.FindByIdAsync(userId.ToString()))
            .ReturnsAsync(user);

        _userManagerMock
            .Setup(x => x.GetRolesAsync(user))
            .ReturnsAsync(Array.Empty<string>());

        // Note: JwtTokenService methods are not virtual, so we use the real implementation
        // The token will be generated by the actual service

        // Act
        var result = await _controller.Token(request, CancellationToken.None);

        // Assert
        result.Should().BeOfType<OkObjectResult>();
        var okResult = result as OkObjectResult;
        var response = okResult!.Value as OAuthTokenResponse;
        response!.Scope.Should().Be("read write");
    }

    #endregion

    #region Refresh Endpoint Tests

    /// <summary>
    /// Test case: Refresh endpoint should return BadRequest when an invalid grant type is provided.
    /// Scenario: An OAuthRefreshTokenRequest is submitted with a grant type other than "refresh_token" (e.g., "password"). The controller should return a BadRequestObjectResult indicating that the grant type must be "refresh_token" for the refresh endpoint.
    /// </summary>
    [Fact]
    public async Task Refresh_WithInvalidGrantType_ShouldReturnBadRequest()
    {
        // Arrange
        var request = new OAuthRefreshTokenRequest
        {
            GrantType = "password",
            RefreshToken = "refresh-token"
        };

        // Act
        var result = await _controller.Refresh(request, CancellationToken.None);

        // Assert
        result.Should().BeOfType<BadRequestObjectResult>();
    }

    /// <summary>
    /// Test case: Refresh endpoint should return BadRequest when the refresh token is missing or empty.
    /// Scenario: An OAuthRefreshTokenRequest is submitted with an empty or whitespace refresh token. The controller should return a BadRequestObjectResult indicating that a refresh token is required for the refresh operation.
    /// </summary>
    [Fact]
    public async Task Refresh_WithMissingRefreshToken_ShouldReturnBadRequest()
    {
        // Arrange
        var request = new OAuthRefreshTokenRequest
        {
            GrantType = "refresh_token",
            RefreshToken = string.Empty
        };

        // Act
        var result = await _controller.Refresh(request, CancellationToken.None);

        // Assert
        result.Should().BeOfType<BadRequestObjectResult>();
    }

    /// <summary>
    /// Test case: Refresh endpoint should return Unauthorized as refresh token validation is not yet implemented.
    /// Scenario: An OAuthRefreshTokenRequest is submitted with a valid grant type and refresh token. Since refresh token validation requires database storage and is not yet implemented, the controller returns an UnauthorizedObjectResult with an error indicating that refresh token validation is not yet available.
    /// </summary>
    [Fact]
    public async Task Refresh_WithValidRequest_ShouldReturnUnauthorized()
    {
        // Arrange
        var request = new OAuthRefreshTokenRequest
        {
            GrantType = "refresh_token",
            RefreshToken = "valid-refresh-token"
        };

        // Act
        var result = await _controller.Refresh(request, CancellationToken.None);

        // Assert
        // Currently returns Unauthorized as refresh token validation is not yet implemented
        result.Should().BeOfType<UnauthorizedObjectResult>();
    }

    #endregion

    #region Authorize Endpoint Tests

    /// <summary>
    /// Test case: Authorize endpoint should return BadRequest as authorization code flow is not yet implemented.
    /// Scenario: An authorization request is submitted with parameters for the authorization code flow (response type, client ID, redirect URI, scope, state). Since the authorization code flow is not yet implemented, the controller returns a BadRequestObjectResult indicating that only the password grant type is currently supported.
    /// </summary>
    [Fact]
    public void Authorize_ShouldReturnBadRequest()
    {
        // Act
        var result = _controller.Authorize("code", "client-id", "http://redirect", "scope", "state");

        // Assert
        result.Should().BeOfType<BadRequestObjectResult>();
    }

    #endregion

    #region JWKS Endpoint Tests

    /// <summary>
    /// Test case: GetJwks endpoint should return a valid JSON Web Key Set (JWKS) response.
    /// Scenario: A request is made to the /.well-known/jwks.json endpoint. The controller should return an OkObjectResult containing a JWKS structure with the public key information (key type, usage, key ID, algorithm, modulus, and exponent) in the standard JWKS format, enabling clients to validate JWT tokens.
    /// </summary>
    [Fact]
    public void GetJwks_ShouldReturnJwksResponse()
    {
        // Act - Using real JwtTokenService instance
        var result = _controller.GetJwks();

        // Assert
        result.Should().BeOfType<OkObjectResult>();
        var okResult = result as OkObjectResult;
        okResult!.Value.Should().NotBeNull();
        
        // Verify JWKS structure
        var jwks = okResult.Value;
        jwks.Should().NotBeNull();
    }

    #endregion

    #region Helper Methods

    private static Mock<UserManager<ApplicationUser>> CreateUserManagerMock()
    {
        var store = new Mock<IUserStore<ApplicationUser>>();
        var userManager = new Mock<UserManager<ApplicationUser>>(
            store.Object,
            null!,
            null!,
            null!,
            null!,
            null!,
            null!,
            null!,
            null!);

        return userManager;
    }

    #endregion
}
