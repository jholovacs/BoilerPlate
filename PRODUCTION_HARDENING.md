# Production Hardening Guide

This guide covers how to harden the BoilerPlate project for production use: trusted certificates, port lockdown, and simplified installation.

**Before starting:** Run `./verify-prerequisites.sh docker-production` or `./verify-prerequisites.sh k8s` to check prerequisites. See [PREREQUISITES.md](PREREQUISITES.md).

---

## 1. Trusted Certificates

### Current State (Development)
- Self-signed TLS certs in `tls-certs/` (generated by `make setup-tls-certs`)
- SAN includes: `localhost`, `host.docker.internal`, `127.0.0.1`
- Frontend nginx serves HTTPS on port 4200 using these certs
- Browsers show security warnings for self-signed certs

### Production Options

#### Option A: Let's Encrypt (Recommended for public-facing)
Use Certbot or ACME to obtain free, trusted certificates:

```bash
# Install certbot (Ubuntu/Debian)
sudo apt install certbot

# Obtain certificate (standalone mode - stop nginx first)
sudo certbot certonly --standalone -d yourdomain.com

# Certificates are in /etc/letsencrypt/live/yourdomain.com/
# fullchain.pem = cert + chain
# privkey.pem = private key
```

Mount these into the frontend container:

```yaml
# docker-compose.production.yml
frontend:
  volumes:
    - /etc/letsencrypt/live/yourdomain.com/fullchain.pem:/etc/nginx/ssl/cert.pem:ro
    - /etc/letsencrypt/live/yourdomain.com/privkey.pem:/etc/nginx/ssl/key.pem:ro
```

#### Option B: Corporate/Internal CA
If you have an internal PKI:

1. Obtain a server certificate from your CA for your production hostname(s)
2. Ensure SAN includes your public hostname(s) and any internal names
3. Place `cert.pem` (or fullchain) and `key.pem` in `tls-certs/` or mount from a secure path
4. Add your CA's root cert to the chain if needed (nginx `ssl_certificate` can be a chain file)

#### Option C: Cloud Load Balancer TLS Termination
If deploying behind AWS ALB, Azure App Gateway, or similar:

- Terminate TLS at the load balancer
- Use the cloud provider's certificate management (ACM, Key Vault, etc.)
- Frontend can run HTTP internally; LB handles HTTPS externally
- Ensure `X-Forwarded-Proto` is set correctly (nginx already forwards this)

### nginx Certificate Paths
The frontend expects:
- `/etc/nginx/ssl/cert.pem` – certificate (or full chain)
- `/etc/nginx/ssl/key.pem` – private key

Override via docker-compose volumes as shown above.

---

## 2. Locking Down Ports

### Current State (Development)
All service ports are exposed to the host:

| Service    | Port  | Exposed | Purpose                    |
|-----------|-------|---------|----------------------------|
| Frontend  | 4200  | Yes     | HTTPS (only public entry)  |
| PostgreSQL| 5432  | Yes     | DB (needed for migrations)|
| RabbitMQ  | 15672 | Yes     | Management UI              |
| MongoDB   | 27017 | Yes     | Logs DB                   |

### Production: Single-Port Deployment

Expose **only** the frontend (port 443 or 4200). All other services stay internal to the Docker network.

#### Step 1: Remove port mappings for internal services

```yaml
# docker-compose.production.yml (or override)
services:
  postgres:
    # Remove or comment out: ports: ["5432:5432"]
    # Migrations: run via docker exec or a one-off migration container
    expose:
      - "5432"  # Internal only

  rabbitmq:
    # Remove: ports: ["15672:15672"]
    expose:
      - "5672"
      - "15672"

  mongodb:
    # Remove: ports: ["27017:27017"]
    expose:
      - "27017"
```

#### Step 2: Run migrations without host port

```bash
# Option 1: Run migration from a temporary container on the same network
docker compose run --rm webapi dotnet ef database update

# Option 2: Use make migrate with POSTGRES_HOST=postgres (container name)
# Requires a migration runner that joins the compose network
```

#### Step 3: Use a non-default port for frontend (optional)

```yaml
frontend:
  ports:
    - "443:443"   # Standard HTTPS
```

### Firewall Rules (Host Level)

On the production host, restrict inbound traffic:

```bash
# UFW example (Ubuntu)
sudo ufw default deny incoming
sudo ufw allow 443/tcp    # HTTPS only
sudo ufw allow 22/tcp     # SSH for admin
sudo ufw enable
```

### Internal-Only Services
- `webapi`, `audit`, `event-logs`, `diagnostics`, `otel-collector`: No ports exposed; reachable only via frontend nginx proxy or internal Docker DNS.

---

## 3. Simplified Installation

### One-Command Production Setup

Create a production setup script that:

1. Validates prerequisites (Docker, OpenSSL, env vars)
2. Generates or validates JWT keys
3. Generates or mounts TLS certs (or uses env to point to existing certs)
4. Creates `.env.production` from template with placeholders
5. Builds images and starts only necessary services
6. Runs migrations via `docker compose run`

### Environment Template for Production

Create `.env.production.example`:

```bash
# JWT (required - generate with: make setup-keys)
JWT_PRIVATE_KEY=<base64-encoded-private-key>
JWT_PUBLIC_KEY=<base64-encoded-public-key>

# Issuer URL (must match your public URL)
JWT_ISSUER_URL=https://yourdomain.com
JWT_EXPIRATION_MINUTES=60

# Database (use strong passwords)
POSTGRES_PASSWORD=<strong-password>
# Connection string is built from these in docker-compose

# MongoDB
MONGO_INITDB_ROOT_PASSWORD=<strong-password>

# RabbitMQ
RABBITMQ_DEFAULT_PASS=<strong-password>

# Admin user (first login)
ADMIN_USERNAME=admin
ADMIN_PASSWORD=<strong-password>
```

### Production docker-compose Override

Create `docker-compose.production.yml`:

```yaml
# docker-compose.production.yml
# Usage: docker compose -f docker-compose.yml -f docker-compose.production.yml up -d

services:
  postgres:
    ports: []  # No host port
    environment:
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}

  rabbitmq:
    ports: []
    environment:
      RABBITMQ_DEFAULT_PASS: ${RABBITMQ_DEFAULT_PASS}

  mongodb:
    ports: []
    environment:
      MONGO_INITDB_ROOT_PASSWORD: ${MONGO_INITDB_ROOT_PASSWORD}

  frontend:
    ports:
      - "443:443"
    # Mount production certs (set TLS_CERT_PATH, TLS_KEY_PATH in .env)
    volumes:
      - ${TLS_CERT_PATH:-./tls-certs/cert.pem}:/etc/nginx/ssl/cert.pem:ro
      - ${TLS_KEY_PATH:-./tls-certs/key.pem}:/etc/nginx/ssl/key.pem:ro

  webapi:
    environment:
      JWT_ISSUER_URL: ${JWT_ISSUER_URL}
      ADMIN_PASSWORD: ${ADMIN_PASSWORD}
```

### Makefile Targets for Production

Add to Makefile:

```makefile
setup-production: verify-prerequisites setup-keys setup-env
	@echo "Ensure TLS certs exist at tls-certs/cert.pem and tls-certs/key.pem"
	@echo "Or set TLS_CERT_PATH and TLS_KEY_PATH in .env"
	@docker compose -f docker-compose.yml -f docker-compose.production.yml build
	@docker compose -f docker-compose.yml -f docker-compose.production.yml run --rm webapi dotnet ef database update
	@docker compose -f docker-compose.yml -f docker-compose.production.yml up -d
	@echo "Production services started. HTTPS on port 443."
```

---

## 4. Security Checklist

| Item | Development | Production |
|------|-------------|------------|
| TLS certs | Self-signed | Trusted (Let's Encrypt or CA) |
| Exposed ports | 4200, 5432, 15672, 27017 | 443 only (or 443 + 22 for SSH) |
| Passwords | Defaults in docs | Strong, unique, from secrets |
| JWT keys | Generated once | Rotate periodically; store in vault |
| `.env` | In repo (gitignored) | Never commit; use secrets manager |
| Swagger/OpenAPI | Enabled | Disable or restrict by IP |
| Health endpoints | Public | Consider IP restrict or auth |

---

## 5. Quick Reference

### Development (current)
```bash
make setup
# Access: https://localhost:4200 (accept self-signed cert)
```

### Production (hardened)
```bash
# 1. Obtain trusted certs (Let's Encrypt or CA)
# 2. Create .env with strong passwords and JWT keys
# 3. Run:
docker compose -f docker-compose.yml -f docker-compose.production.yml up -d
# Access: https://yourdomain.com (no cert warning)
```

### Migrations in Production
Migrations run from the host using `dotnet ef` (postgres must be reachable). Run migrations *before* or *during* setup-production:

```bash
# Option 1: Via make (ensure-services starts postgres with port 5432 for migration)
make migrate-production

# Option 2: Manual - start base compose first, then migrate
docker compose up -d postgres
make migrate
# Then apply production override
make docker-up-production
```
